using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace GodotSimpleToolsSourceGenerators.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class ReceiverGenerator : IIncrementalGenerator
{
    private const string ReceiverAttributeName = "GodotSimpleTools.Attributes.ReceiverAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var receiverMethods = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                ReceiverAttributeName,
                static (node, _) => node is MethodDeclarationSyntax,
                static (attributeContext, _) => GetMethodInfo(attributeContext))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);

        var collectedMethods = receiverMethods.Collect();

        context.RegisterSourceOutput(
            collectedMethods,
            static (sourceProductionContext, methods) =>
            {
                if (methods.IsDefaultOrEmpty)
                {
                    return;
                }

                GenerateSource(sourceProductionContext, methods);
            });
    }

private static ReceiverMethodInfo? GetMethodInfo(GeneratorAttributeSyntaxContext context)
{
    if (context.TargetNode is not MethodDeclarationSyntax methodDecl ||
        context.TargetSymbol is not IMethodSymbol methodSymbol)
        return null;

    if (methodSymbol.ContainingType is not { } containingType || !IsPartial(containingType))
        return null;

    var semanticModel = context.SemanticModel;

    // 找到方法上所有 ReceiverAttribute
    var attributeSyntaxes = methodDecl.AttributeLists
        .SelectMany(al => al.Attributes)
        .Where(a =>
        {
            var symbol = semanticModel.GetSymbolInfo(a).Symbol;
            return symbol is IMethodSymbol m && m.ContainingType?.ToDisplayString() == ReceiverAttributeName;
        })
        .ToArray();

    if (attributeSyntaxes.Length == 0)
        return null;

    var receiverInfos = new List<ReceiverInfo>(attributeSyntaxes.Length);
    foreach (var attr in attributeSyntaxes)
    {
        if (attr.ArgumentList == null || attr.ArgumentList.Arguments.Count < 1)
            continue;

        var firstArgSyntax = attr.ArgumentList.Arguments[0];
        string eventNameLiteral = firstArgSyntax.Expression.ToString(); // 保留原始表达式
        string eventName = ExtractEventName(eventNameLiteral);
        if (!string.IsNullOrEmpty(eventName))
        {
            receiverInfos.Add(new ReceiverInfo(eventName));
        }
    }

    if (receiverInfos.Count == 0)
        return null;

    var parameters = methodSymbol.Parameters.Select(p => p.Type.ToDisplayString()).ToList();

    return new ReceiverMethodInfo(containingType, methodSymbol.Name, parameters, receiverInfos);
}

// 将原始表达式解析为“事件名”的纯文本
private static string ExtractEventName(string raw)
{
    if (raw.StartsWith("nameof(", StringComparison.Ordinal) && raw.EndsWith(")"))
    {
        return raw.Substring(7, raw.Length - 8); // 去掉 "nameof(" 和 ")"
    }

    if (raw.Length >= 2 && raw[0] == '"' && raw[raw.Length - 1] == '"')
    {
        return raw.Substring(1, raw.Length - 2); // 去掉首尾引号
    }

    // 其他表达式原样保留（可按需扩展或给出诊断）
    return raw;
}

    private static bool IsPartial(INamedTypeSymbol typeSymbol)
    {
        foreach (var syntaxReference in typeSymbol.DeclaringSyntaxReferences)
        {
            if (syntaxReference.GetSyntax() is TypeDeclarationSyntax typeDeclaration &&
                typeDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
            {
                return true;
            }
        }

        return false;
    }

    private static void GenerateSource(
        SourceProductionContext context,
        ImmutableArray<ReceiverMethodInfo> methods)
    {
        var groups = methods
            .GroupBy(static method => method.ContainingType, SymbolEqualityComparer.Default);

        foreach (var group in groups)
        {
            if (group.Key is not INamedTypeSymbol classSymbol)
            {
                continue;
            }

            var source = BuildClassSource(classSymbol, group.ToArray());
            var hintName = $"{classSymbol.Name}_ReceiverGenerator.g.cs";
            context.AddSource(hintName, source);
        }
    }

    private static string BuildClassSource(
        INamedTypeSymbol classSymbol,
        IReadOnlyList<ReceiverMethodInfo> methods)
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        var namespaceName = classSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : classSymbol.ContainingNamespace.ToDisplayString();

        if (!string.IsNullOrWhiteSpace(namespaceName))
        {
            builder.Append("namespace ").Append(namespaceName).AppendLine(";");
            builder.AppendLine();
        }

        builder.Append("public partial ").Append(GetTypeDeclaration(classSymbol)).AppendLine();
        builder.AppendLine("{");

        WriteInitNotifies(builder, methods);
        builder.AppendLine();
        WriteDestroyNotifies(builder, methods);

        builder.AppendLine("}");

        return builder.ToString();
    }

    private static void WriteInitNotifies(StringBuilder builder, IReadOnlyList<ReceiverMethodInfo> methods)
    {
        builder.AppendLine("    public void InitNotifies()");
        builder.AppendLine("    {");

        foreach (var method in methods)
        {
            foreach (var receiver in method.Receivers)
            {
                builder.Append("        ")
                    .Append(receiver.EventName)
                    .Append(" += ")
                    .Append(method.MethodName)
                    .AppendLine(";");
            }
        }

        builder.AppendLine("    }");
    }

    private static void WriteDestroyNotifies(StringBuilder builder, IReadOnlyList<ReceiverMethodInfo> methods)
    {
        builder.AppendLine("    public void DestroyNotifies()");
        builder.AppendLine("    {");

        foreach (var method in methods)
        {
            foreach (var receiver in method.Receivers)
            {
                builder.Append("        ")
                    .Append(receiver.EventName)
                    .Append(" -= ")
                    .Append(method.MethodName)
                    .AppendLine(";");
            }
        }

        builder.AppendLine("    }");
    }

    private static string GetTypeDeclaration(INamedTypeSymbol classSymbol)
    {
        var typeKeyword = classSymbol.TypeKind == TypeKind.Struct ? "struct" : "class";

        var typeParameters = classSymbol.TypeParameters.Length > 0
            ? $"<{string.Join(", ", classSymbol.TypeParameters.Select(parameter => parameter.Name))}>"
            : string.Empty;

        var constraints = BuildTypeParameterConstraints(classSymbol);

        return $"{typeKeyword} {classSymbol.Name}{typeParameters}{constraints}";
    }

    private static string BuildTypeParameterConstraints(INamedTypeSymbol classSymbol)
    {
        if (classSymbol.TypeParameters.Length == 0)
        {
            return string.Empty;
        }

        var builder = new StringBuilder();

        foreach (var parameter in classSymbol.TypeParameters)
        {
            var clauses = new List<string>();

            if (parameter.HasReferenceTypeConstraint)
            {
                clauses.Add("class");
            }
            else if (parameter.HasValueTypeConstraint)
            {
                clauses.Add("struct");
            }

            if (parameter.HasNotNullConstraint)
            {
                clauses.Add("notnull");
            }

            if (parameter.HasUnmanagedTypeConstraint)
            {
                clauses.Add("unmanaged");
            }

            clauses.AddRange(parameter.ConstraintTypes.Select(
                type => type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));

            if (parameter.HasConstructorConstraint)
            {
                clauses.Add("new()");
            }

            if (clauses.Count == 0)
            {
                continue;
            }

            builder.Append(" where ")
                .Append(parameter.Name)
                .Append(" : ")
                .Append(string.Join(", ", clauses));
        }

        return builder.ToString();
    }

    private sealed class ReceiverMethodInfo
    {
        public ReceiverMethodInfo(
            INamedTypeSymbol containingType,
            string methodName,
            IReadOnlyList<string> parameters,
            IReadOnlyList<ReceiverInfo> receivers)
        {
            ContainingType = containingType;
            MethodName = methodName;
            Parameters = parameters;
            Receivers = receivers;
        }

        public INamedTypeSymbol ContainingType { get; }
        public string MethodName { get; }
        public IReadOnlyList<string> Parameters { get; }
        public IReadOnlyList<ReceiverInfo> Receivers { get; }
    }

    private sealed class ReceiverInfo
    {
        public ReceiverInfo(string eventName)
        {
            EventName = eventName;
        }

        public string EventName { get; }
    }
}